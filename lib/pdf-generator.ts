import { jsPDF } from 'jspdf';

interface ReportData {
  reportContent: string;
  metadata: {
    title: string;
    dateRange: string;
    generatedAt: string;
    period: string;
  };
  generatedBy: string;
}

interface ChartData {
  title: string;
  type: 'bar' | 'pie' | 'line';
  data: any;
  canvas?: HTMLCanvasElement;
}

export class PDFReportGenerator {
  private doc: jsPDF;
  private pageWidth: number;
  private pageHeight: number;
  private margin: number;
  private currentY: number;
  private lineHeight: number;

  constructor() {
    this.doc = new jsPDF('p', 'mm', 'a4');
    this.pageWidth = this.doc.internal.pageSize.getWidth();
    this.pageHeight = this.doc.internal.pageSize.getHeight();
    this.margin = 20;
    this.currentY = this.margin;
    this.lineHeight = 7;
  }

  private addNewPageIfNeeded(requiredHeight: number = 20): void {
    if (this.currentY + requiredHeight > this.pageHeight - this.margin) {
      this.doc.addPage();
      this.currentY = this.margin;
    }
  }

  private addHeader(title: string): void {
    // Add logo/header background
    this.doc.setFillColor(16, 58, 94); // GusoSync blue color
    this.doc.rect(0, 0, this.pageWidth, 40, 'F');
    
    // Add title
    this.doc.setTextColor(255, 255, 255);
    this.doc.setFontSize(24);
    this.doc.setFont('helvetica', 'bold');
    this.doc.text(title, this.margin, 25);
    
    // Add subtitle
    this.doc.setFontSize(12);
    this.doc.setFont('helvetica', 'normal');
    this.doc.text('Transportation System Analytics Report', this.margin, 32);
    
    this.currentY = 50;
  }

  private addFooter(pageNumber: number, totalPages: number, generatedBy: string): void {
    const footerY = this.pageHeight - 15;
    
    // Add footer line
    this.doc.setDrawColor(200, 200, 200);
    this.doc.line(this.margin, footerY - 5, this.pageWidth - this.margin, footerY - 5);
    
    // Add page number
    this.doc.setTextColor(100, 100, 100);
    this.doc.setFontSize(10);
    this.doc.setFont('helvetica', 'normal');
    this.doc.text(`Page ${pageNumber} of ${totalPages}`, this.pageWidth - this.margin - 30, footerY);
    
    // Add generated by
    this.doc.text(`Generated by: ${generatedBy}`, this.margin, footerY);
    
    // Add generation date
    const now = new Date().toLocaleString();
    this.doc.text(`Generated on: ${now}`, this.margin + 80, footerY);
  }

  private addSection(title: string, content: string): void {
    this.addNewPageIfNeeded(30);
    
    // Section title
    this.doc.setTextColor(16, 58, 94);
    this.doc.setFontSize(16);
    this.doc.setFont('helvetica', 'bold');
    this.doc.text(title, this.margin, this.currentY);
    this.currentY += this.lineHeight + 3;
    
    // Section content
    this.doc.setTextColor(0, 0, 0);
    this.doc.setFontSize(11);
    this.doc.setFont('helvetica', 'normal');
    
    const lines = this.doc.splitTextToSize(content, this.pageWidth - 2 * this.margin);
    
    for (const line of lines) {
      this.addNewPageIfNeeded(this.lineHeight);
      this.doc.text(line, this.margin, this.currentY);
      this.currentY += this.lineHeight;
    }
    
    this.currentY += 5; // Add space after section
  }

  private addMetadataTable(metadata: any): void {
    this.addNewPageIfNeeded(40);
    
    // Table header
    this.doc.setFillColor(240, 240, 240);
    this.doc.rect(this.margin, this.currentY, this.pageWidth - 2 * this.margin, 8, 'F');
    
    this.doc.setTextColor(0, 0, 0);
    this.doc.setFontSize(12);
    this.doc.setFont('helvetica', 'bold');
    this.doc.text('Report Information', this.margin + 5, this.currentY + 6);
    this.currentY += 12;
    
    // Table rows
    const rows = [
      ['Report Period:', metadata.period],
      ['Date Range:', metadata.dateRange],
      ['Generated At:', new Date(metadata.generatedAt).toLocaleString()],
    ];
    
    this.doc.setFontSize(10);
    this.doc.setFont('helvetica', 'normal');
    
    for (const [label, value] of rows) {
      this.doc.setFont('helvetica', 'bold');
      this.doc.text(label, this.margin + 5, this.currentY);
      this.doc.setFont('helvetica', 'normal');
      this.doc.text(value, this.margin + 50, this.currentY);
      this.currentY += this.lineHeight;
    }
    
    this.currentY += 10;
  }

  private addChart(chartData: ChartData): void {
    this.addNewPageIfNeeded(80);
    
    // Chart title
    this.doc.setTextColor(16, 58, 94);
    this.doc.setFontSize(14);
    this.doc.setFont('helvetica', 'bold');
    this.doc.text(chartData.title, this.margin, this.currentY);
    this.currentY += 10;
    
    // Add chart placeholder (in a real implementation, you would render the actual chart)
    this.doc.setDrawColor(200, 200, 200);
    this.doc.setFillColor(250, 250, 250);
    const chartHeight = 60;
    const chartWidth = this.pageWidth - 2 * this.margin;
    
    this.doc.rect(this.margin, this.currentY, chartWidth, chartHeight, 'FD');
    
    // Add chart type indicator
    this.doc.setTextColor(100, 100, 100);
    this.doc.setFontSize(10);
    this.doc.text(`[${chartData.type.toUpperCase()} CHART]`, this.margin + chartWidth/2 - 20, this.currentY + chartHeight/2);
    
    // Add data summary
    if (chartData.data && typeof chartData.data === 'object') {
      this.doc.setFontSize(9);
      let dataText = 'Data: ';
      if (Array.isArray(chartData.data)) {
        dataText += `${chartData.data.length} data points`;
      } else {
        const entries = Object.entries(chartData.data).slice(0, 3);
        dataText += entries.map(([key, value]) => `${key}: ${value}`).join(', ');
        if (Object.keys(chartData.data).length > 3) {
          dataText += '...';
        }
      }
      this.doc.text(dataText, this.margin + 5, this.currentY + chartHeight - 5);
    }
    
    this.currentY += chartHeight + 15;
  }

  private parseReportContent(content: string): { sections: Array<{title: string, content: string}>, charts: ChartData[] } {
    const sections: Array<{title: string, content: string}> = [];
    const charts: ChartData[] = [];
    
    // Split content by sections (assuming markdown-style headers)
    const lines = content.split('\n');
    let currentSection = { title: '', content: '' };
    
    for (const line of lines) {
      if (line.startsWith('# ') || line.startsWith('## ') || line.startsWith('### ')) {
        // Save previous section
        if (currentSection.title) {
          sections.push({ ...currentSection });
        }
        
        // Start new section
        currentSection = {
          title: line.replace(/^#+\s*/, ''),
          content: ''
        };
      } else if (line.trim()) {
        currentSection.content += line + '\n';
      }
    }
    
    // Add last section
    if (currentSection.title) {
      sections.push(currentSection);
    }
    
    // Extract potential chart references (this is a simplified approach)
    // In a real implementation, you would have actual chart data
    const chartKeywords = ['chart', 'graph', 'visualization', 'trend', 'distribution'];
    sections.forEach(section => {
      const hasChartKeyword = chartKeywords.some(keyword => 
        section.title.toLowerCase().includes(keyword) || 
        section.content.toLowerCase().includes(keyword)
      );
      
      if (hasChartKeyword) {
        charts.push({
          title: section.title,
          type: section.title.toLowerCase().includes('trend') ? 'line' : 
                section.title.toLowerCase().includes('distribution') ? 'pie' : 'bar',
          data: { placeholder: 'Chart data would be here' }
        });
      }
    });
    
    return { sections, charts };
  }

  public async generateReport(reportData: ReportData): Promise<Uint8Array> {
    try {
      // Add header
      this.addHeader(reportData.metadata.title);
      
      // Add metadata table
      this.addMetadataTable(reportData.metadata);
      
      // Parse report content
      const { sections, charts } = this.parseReportContent(reportData.reportContent);
      
      // Add sections
      for (const section of sections) {
        this.addSection(section.title, section.content);
      }
      
      // Add charts
      for (const chart of charts) {
        this.addChart(chart);
      }
      
      // Add footers to all pages
      const totalPages = this.doc.getNumberOfPages();
      for (let i = 1; i <= totalPages; i++) {
        this.doc.setPage(i);
        this.addFooter(i, totalPages, reportData.generatedBy);
      }
      
      // Return PDF as Uint8Array
      return this.doc.output('arraybuffer') as Uint8Array;
      
    } catch (error) {
      console.error('Error generating PDF:', error);
      throw new Error('Failed to generate PDF report');
    }
  }
}
